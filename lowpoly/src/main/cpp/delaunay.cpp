/* DO NOT EDIT THIS FILE - it is machine generated */
#include "delaunay.h"

#include <iostream>
#include <vector>
#include <stdlib.h>
#include <limits>
#include <algorithm>
#include <math.h>
#include <string.h>
#include <memory.h>

using std::cout;
using std::endl;
using std::vector;
using std::sort;

/* Header for class com_linecutfeng_lowpoly_Delaunay */

#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_linecutfeng_lowpoly_Delaunay
 * Method:    triangulateFromNative
 * Signature: (Ljava/util/List;)Ljava/util/List;
 */

int max(int a, int b) {
    if (a >= b) return a;
    else return b;
}
int min(int a, int b) {
    if (a <= b) return a;
    else return b;
}




static int **supertriangle(vector<int *> &vertices) {

    int xmin = INT_MAX;
    int ymin = INT_MAX;
    int xmax = INT_MIN;
    int ymax = INT_MIN;

    float dx, dy, dmax, xmid, ymid;
    int p[2];
    for (int i = vertices.size() - 1; i >= 0; i--) {
        p[0] = vertices[i][0];
        p[1] = vertices[i][1];
        if (p[0] < xmin) xmin = p[0];
        if (p[0] > xmax) xmax = p[0];
        if (p[1] < ymin) ymin = p[1];
        if (p[1] > ymax) ymax = p[1];
    }

    dx = xmax - xmin;
    dy = ymax - ymin;
    dmax = fmax(dx, dy);

    xmid = (xmin + dx * 0.5f);
    ymid = (ymin + dy * 0.5f);
    int **returnArraynew;
    returnArraynew = new int *[3];
    for (int i = 0; i < 3; ++i) {
        returnArraynew[i] = new int[2];
    }
    returnArraynew[0][0] = (int) (xmid - 20 * dmax);
    returnArraynew[0][1] = (int) (ymid - dmax);
    returnArraynew[1][0] = (int) xmid;
    returnArraynew[1][1] = (int) (ymid + 20 * dmax);
    returnArraynew[2][0] = (int) (xmid + 20 * dmax);
    returnArraynew[2][1] = (int) (ymid - dmax);

    /*new int[3][2]{{(int) (xmid - 20 * dmax), (int) (ymid - dmax)},
                    {(int) xmid,               (int) (ymid + 20 * dmax)},
                    {(int) (xmid + 20 * dmax), (int) (ymid - dmax)}};*/
    return returnArraynew;
}

static void dedup(vector<int> edges) {
    int a, b, m, n;
    for (int j = edges.size(); j > 0;) {
        while (j > edges.size()) {
            j--;
        }
        if (j <= 0) {
            break;
        }
        b = edges[--j];
        a = edges[--j];

        for (int i = j; i > 0;) {
            n = edges[--i];
            m = edges[--i];

            if ((a == m && b == n) || (a == n && b == m)) {
                if (j + 1 < edges.size())
                    edges.erase(edges.begin() + j + 1);
                edges.erase(edges.begin() + j);
                if (i + 1 < edges.size())
                    edges.erase(edges.begin() + i + 1);
                edges.erase(edges.begin() + i);
                break;
            }
        }
    }
}

JNIEXPORT jobject JNICALL Java_com_linecutfeng_lowpoly_Delaunay_triangulateFromNative
        (JNIEnv *env, jclass jclass1, jobject verticesList) {
    jclass arrayListClass = env->GetObjectClass(verticesList);
    jmethodID mSize = env->GetMethodID(arrayListClass, "size", "()I");
    jmethodID list_get = env->GetMethodID(arrayListClass, "get", "(I)Ljava/lang/Object;");
    jint n = env->CallIntMethod(verticesList, mSize);
    if (n < 3) {
        jclass arrayListClazz = env->FindClass("java/util/ArrayList");
        jmethodID newArrayList = env->GetMethodID(arrayListClazz, "<init>", "()V");
        jobject pJobject = env->NewObject(arrayListClazz, newArrayList);
        return pJobject;
    }
    int **verticesArray = new int *[n];
    for (int i = 0; i < n; ++i) {
        verticesArray[i] = new int[2];
        jint jInt = i;
        jintArray array = (jintArray) (env->CallObjectMethod(verticesList, list_get, jInt));
        jint *pInt = env->GetIntArrayElements(array, NULL);
        verticesArray[i][0] = pInt[0];
        verticesArray[i][1] = pInt[1];
    }
    int *indices = new int[n];
    for (int i = n - 1; i >= 0; i--) {
        indices[i] = i;
    }
    for (int i = 0; i < n - 1; ++i) {
        for (int j = i + 1; j < n; ++j) {
            if (verticesArray[i][0] > verticesArray[j][0]) {
                int temp = indices[i];
                indices[i] = indices[j];
                indices[j] = temp;
            }
        }
    }
//    supertriangle();
    return NULL;
}

static Circumcircle *circumcircle(vector<int *> vertices, int i, int j, int k) {

    int x1 = vertices[i][0];
    int y1 = vertices[i][1];
    int x2 = vertices[j][0];
    int y2 = vertices[j][1];
    int x3 = vertices[k][0];
    int y3 = vertices[k][1];


    int fabsy1y2 = abs(y1 - y2);
    int fabsy2y3 = abs(y2 - y3);

    float xc, yc, m1, m2, mx1, mx2, my1, my2, dx, dy;

//        if (fabsy1y2 <= 0 && fabsy2y3 <= 0) {
//            throw new RuntimeException("Eek! Coincident points!");
//        }

    if (fabsy1y2 <= 0) {
        m2 = -((float) (x3 - x2) / (y3 - y2));
        mx2 = (x2 + x3) / 2.0f;
        my2 = (y2 + y3) / 2.0f;
        xc = (x2 + x1) / 2.0f;
        yc = m2 * (xc - mx2) + my2;
    } else if (fabsy2y3 <= 0) {
        m1 = -((float) (x2 - x1) / (y2 - y1));
        mx1 = (x1 + x2) / 2.0f;
        my1 = (y1 + y2) / 2.0f;
        xc = (x3 + x2) / 2.0f;
        yc = m1 * (xc - mx1) + my1;
    } else {
        m1 = -((float) (x2 - x1) / (y2 - y1));
        m2 = -((float) (x3 - x2) / (y3 - y2));
        mx1 = (x1 + x2) / 2.0f;
        mx2 = (x2 + x3) / 2.0f;
        my1 = (y1 + y2) / 2.0f;
        my2 = (y2 + y3) / 2.0f;
        xc = (m1 * mx1 - m2 * mx2 + my2 - my1) / (m1 - m2);
        yc = (fabsy1y2 > fabsy2y3) ?
             m1 * (xc - mx1) + my1 :
             m2 * (xc - mx2) + my2;
    }

    dx = x2 - xc;
    dy = y2 - yc;

    return new Circumcircle(i, j, k, xc, yc, (dx * dx + dy * dy));
}

#ifdef __cplusplus
}
#endif
